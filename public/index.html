<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Twilio Browser Receiver (auto-detect + DTMF)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;display:flex;align-items:center;justify-content:center;height:100vh;margin:0;background:#f6f8fa;}
    .card{background:#fff;padding:22px;border-radius:12px;box-shadow:0 6px 20px rgba(0,0,0,0.08);width:520px;text-align:center;}
    button{padding:10px 14px;border-radius:8px;border:none;background:#0b74de;color:#fff;font-weight:600;cursor:pointer;}
    #status{margin:12px 0;color:#333;}
    #incoming{display:none;margin-top:12px;}
    #answer, #reject{margin:6px;}
    .small{font-size:13px;color:#666;}
    pre {text-align:left; margin:8px 0; max-height:180px; overflow:auto; background:#f0f3f6; padding:8px; border-radius:6px;}
    .dtmf{padding:10px;border-radius:8px;border:1px solid #ddd;background:#fff;cursor:pointer;font-weight:600;}
    #dtmfKeys button{font-size:16px}
    #dtmfHistory {font-size:13px;}
  </style>

  <!-- Twilio v2 build (you told me you use this CDN) -->
  <script src="https://unpkg.com/@twilio/voice-sdk@2.16.0/dist/twilio.min.js"></script>
</head>
<body>
  <div class="card">
    <h2>Twilio Browser Receiver</h2>

    <div id="status">Click <strong>Enable calls</strong> to allow microphone & register device.</div>
    <div style="margin:10px 0">
      <button id="startBtn">Enable calls</button>
    </div>

    <div class="small">Keep this tab open. Incoming calls to your Twilio number will ring here.</div>

    <div id="incoming">
      <p><strong id="fromLabel">Incoming call</strong></p>
      <div>
        <button id="answer">Answer</button>
        <button id="reject" style="background:#e23b3b">Reject</button>
      </div>
    </div>

    <div style="margin-top:14px">
      <button id="muteToggle">Mute</button>
    </div>

    <!-- ===== DTMF keypad ===== -->
    <div id="dtmfWrap" style="margin-top:12px; text-align:center;">
      <div style="margin-bottom:6px; font-size:13px; color:#666;">DTMF keypad — press while a call is active</div>
      <div id="dtmfKeys" style="display:grid; grid-template-columns:repeat(3,1fr); gap:6px; max-width:320px; margin:0 auto;">
        <button class="dtmf" data-digit="1">1</button>
        <button class="dtmf" data-digit="2">2</button>
        <button class="dtmf" data-digit="3">3</button>
        <button class="dtmf" data-digit="4">4</button>
        <button class="dtmf" data-digit="5">5</button>
        <button class="dtmf" data-digit="6">6</button>
        <button class="dtmf" data-digit="7">7</button>
        <button class="dtmf" data-digit="8">8</button>
        <button class="dtmf" data-digit="9">9</button>
        <button class="dtmf" data-digit="*">*</button>
        <button class="dtmf" data-digit="0">0</button>
        <button class="dtmf" data-digit="#">#</button>
      </div>

      <div style="margin-top:8px;">
        <button id="sendSeq" style="margin-right:8px;">Send sequence</button>
        <input id="dtmfSeq" placeholder="e.g. 123w45#" style="width:200px;padding:6px;border-radius:6px;border:1px solid #ddd;" />
      </div>
      <div style="font-size:12px;color:#888;margin-top:6px;">
        Use <code>w</code> to pause (~500ms). Allowed: 0–9, *, #, w.
      </div>
    </div>

    <!-- History & manual flush -->
    <div id="dtmfHistoryWrap" style="margin-top:12px; text-align:left; max-width:320px; margin-left:auto; margin-right:auto;">
      <div style="font-size:12px;color:#666;margin-bottom:6px;">DTMF history (most recent first)</div>
      <div id="dtmfHistory" style="background:#fff;padding:8px;border-radius:6px;border:1px solid #eee;max-height:120px;overflow:auto;font-size:13px;color:#333;"></div>
      <div style="margin-top:6px; text-align:center;">
        <button id="flushNow" style="margin-top:6px; padding:6px 10px;font-size:13px">Flush now</button>
      </div>
    </div>

    <div style="margin-top:12px">
      <details><summary>Debug: detected Twilio global (open and check console)</summary>
        <pre id="twilioDebug">(not loaded yet)</pre>
      </details>
    </div>
  </div>

  <script>
    /***** Utility & detection *****/
    function detectTwilioDeviceConstructor() {
      const accessPaths = [
        ['window.Twilio', window.Twilio],
        ['window.Twilio && window.Twilio.Device', (window.Twilio && window.Twilio.Device)],
        ['window.Twilio.default', (window.Twilio && window.Twilio.default)],
        ['window.Twilio.default.Device', (window.Twilio && window.Twilio.default && window.Twilio.default.Device)],
        ['window.TwilioVoice', window.TwilioVoice],
        ['window.TwilioVoice.Device', (window.TwilioVoice && window.TwilioVoice.Device)],
        ['window.TwilioVoice.default', (window.TwilioVoice && window.TwilioVoice.default)],
        ['window.TwilioVoice.default.Device', (window.TwilioVoice && window.TwilioVoice.default && window.TwilioVoice.default.Device)],
        ['window["@twilio/voice-sdk"] (rare)', window['@twilio/voice-sdk']]
      ];

      function looksLikeConstructor(fn) { return typeof fn === 'function'; }

      const twilioGlobal = window.Twilio || window.TwilioVoice || window.TwilioVoiceSDK || window.TwilioClient || window['@twilio/voice-sdk'] || null;
      function snapshot(obj) {
        if (!obj) return null;
        try { return Object.keys(obj).slice(0,50); } catch (e) { return String(obj); }
      }

      for (const [path, val] of accessPaths) {
        if (looksLikeConstructor(val)) return { constructor: val, path, twilioGlobalSnapshot: snapshot(twilioGlobal) };
        if (val && typeof val === 'object') {
          if (looksLikeConstructor(val.Device)) return { constructor: val.Device, path: path + '.Device', twilioGlobalSnapshot: snapshot(twilioGlobal) };
          if (looksLikeConstructor(val.default)) return { constructor: val.default, path: path + '.default', twilioGlobalSnapshot: snapshot(twilioGlobal) };
          if (val.default && typeof val.default === 'object' && looksLikeConstructor(val.default.Device)) {
            return { constructor: val.default.Device, path: path + '.default.Device', twilioGlobalSnapshot: snapshot(twilioGlobal) };
          }
        }
      }
      return { constructor: null, path: null, twilioGlobalSnapshot: snapshot(twilioGlobal) };
    }

    /***** UI refs & state *****/
    const startBtn = document.getElementById('startBtn');
    const incomingBox = document.getElementById('incoming');
    const fromLabel = document.getElementById('fromLabel');
    const statusEl = document.getElementById('status');
    const debugPre = document.getElementById('twilioDebug');

    function setStatus(t) { statusEl.innerText = t; }
    function logDebug(...args) { console.debug('[twilio]', ...args); }

    // global call reference & dtmf queue (used by keypad)
    window.activeCall = null;
    window._dtmfQueue = [];

    /***** Token fetcher *****/
    async function fetchToken() {
      const res = await fetch('/token');
      if (!res.ok) {
        const b = await res.json().catch(()=>({ error: 'unknown' }));
        throw new Error(b.error || 'Failed to fetch token');
      }
      const j = await res.json();
      return j.token;
    }

    /***** Start / register device and wire events *****/
    async function startDevice() {
      setStatus('Fetching token…');
      try {
        const token = await fetchToken();

        const detected = detectTwilioDeviceConstructor();
        console.log('Detected Twilio global:', detected.twilioGlobalSnapshot, 'chosen path:', detected.path);
        debugPre.innerText = 'Detected global keys: ' + JSON.stringify(detected.twilioGlobalSnapshot, null, 0) + '\nChosen path: ' + String(detected.path);

        if (!detected.constructor) {
          setStatus('Twilio SDK loaded but Device constructor not found. See console for details.');
          console.error('Twilio SDK loaded but could not find Device constructor. Snapshot:', detected.twilioGlobalSnapshot);
          return;
        }

        const DeviceCtor = detected.constructor;
        try {
          // instantiate device (v2 style)
          const device = new DeviceCtor(token);
          // expose for debugging if needed
          window._twilioDeviceInstance = device;

          // register events
          device.on && device.on('registered', () => {
            setStatus('Ready — waiting for calls.');
            startBtn.style.display = 'none';
          });

          device.on && device.on('registrationError', (err) => {
            console.error('registrationError', err);
            setStatus('Registration error: ' + (err && err.message ? err.message : String(err)));
          });

          device.on && device.on('unregistered', () => {
            setStatus('Device unregistered');
            startBtn.style.display = '';
          });

          // incoming
          device.on && device.on('incoming', (call) => {
            // store call globally so keypad can access and queue can work
            window.activeCall = call;
            logDebug('Incoming call object set to window.activeCall', call);

            const from = call.parameters && call.parameters.From ? call.parameters.From : 'Unknown';
            fromLabel.innerText = 'Incoming call from ' + from;
            incomingBox.style.display = 'block';
            setStatus('Incoming call from ' + from);

            // wired lifecycle events (ensure we flush queued DTMF once connected)
            call.on && call.on('connected', () => {
              logDebug('Call connected event — flushing DTMF queue if any');
              // keep global ref
              window.activeCall = call;
              setStatus('Call connected');
              flushDtmfQueue();
            });

            call.on && call.on('disconnected', () => {
              logDebug('Call disconnected');
              if (window.activeCall === call) window.activeCall = null;
              setStatus('Call disconnected');
              incomingBox.style.display = 'none';
              window._dtmfQueue = [];
            });

            call.on && call.on('failed', (err) => {
              console.error('call failed', err);
              if (window.activeCall === call) window.activeCall = null;
              setStatus('Call failed: ' + (err && err.message ? err.message : String(err)));
              incomingBox.style.display = 'none';
            });
          });

          // register device (triggers mic permissions)
          if (typeof device.register === 'function') {
            await device.register();
          } else {
            console.warn('Device.register() not present; continuing');
          }

        } catch (ctorErr) {
          console.error('Failed constructing Device with detected constructor. Constructor type:', typeof DeviceCtor, DeviceCtor);
          setStatus('Failed to create Device — constructor threw (see console).');
          return;
        }

      } catch (err) {
        console.error('startDevice error', err);
        setStatus('Initialization failed: ' + (err && err.message ? err.message : String(err)));
      }
    }

    /***** Answer / reject handlers (keeps queue flush attempts) *****/
    document.getElementById('answer').addEventListener('click', async () => {
      if (!window.activeCall) { setStatus('No incoming call to answer'); return; }
      try {
        await window.activeCall.accept && window.activeCall.accept();
        setStatus('Answering… waiting for connected');
        addHistory('Answer pressed — waiting to flush queued DTMF');
        scheduleAutoFlush();
        setTimeout(() => { try { flushDtmfQueue(); } catch(e){console.error(e);} }, 600);
        setTimeout(() => { try { flushDtmfQueue(); } catch(e){console.error(e);} }, 1400);
      } catch (err) {
        console.error('Accept failed', err);
        setStatus('Answer failed: ' + (err && err.message ? err.message : err));
      }
    });

    document.getElementById('reject').addEventListener('click', () => {
      if (!window.activeCall) { setStatus('No incoming call to reject'); return; }
      try {
        window.activeCall.reject && window.activeCall.reject();
        setStatus('Call rejected');
        window.activeCall = null;
        incomingBox.style.display = 'none';
        window._dtmfQueue = [];
        addHistory('Call rejected — cleared queue');
      } catch (err) {
        console.error('Reject failed', err);
        setStatus('Reject failed: ' + (err && err.message ? err.message : err));
      }
    });

    /***** Mute toggle *****/
    document.getElementById('muteToggle').addEventListener('click', () => {
      if (!window.activeCall) { setStatus('No active call to mute/unmute'); return; }
      try {
        window._isMuted = !window._isMuted;
        window.activeCall.mute && window.activeCall.mute(window._isMuted);
        setStatus(window._isMuted ? 'Muted' : 'Unmuted');
      } catch (err) {
        console.error('Mute toggle failed', err);
      }
    });

    /***** DTMF handling: immediate attempts, queueing & flushing *****/
    function addHistory(msg) {
      try {
        const el = document.getElementById('dtmfHistory');
        const line = document.createElement('div');
        line.style.borderBottom = '1px dashed #eee';
        line.style.padding = '6px 0';
        line.textContent = new Date().toLocaleTimeString() + ' — ' + msg;
        el.insertBefore(line, el.firstChild);
      } catch(e){ console.debug('history error', e); }
    }

    function trySendNow(call, digits) {
      if (!call) return false;
      try {
        if (typeof call.sendDigits === 'function') {
          call.sendDigits(String(digits));
          addHistory('Sent (sendDigits): ' + digits);
          console.debug('Sent DTMF via sendDigits:', digits);
          return true;
        }
        if (typeof call.dtmf === 'function') {
          call.dtmf(String(digits));
          addHistory('Sent (dtmf): ' + digits);
          console.debug('Sent DTMF via dtmf():', digits);
          return true;
        }
        if (typeof call.sendTone === 'function') {
          call.sendTone(String(digits));
          addHistory('Sent (sendTone): ' + digits);
          console.debug('Sent DTMF via sendTone():', digits);
          return true;
        }
        if (typeof call._sendDigits === 'function') {
          call._sendDigits(String(digits));
          addHistory('Sent (_sendDigits): ' + digits);
          console.debug('Sent DTMF via _sendDigits:', digits);
          return true;
        }
      } catch (err) {
        console.warn('Immediate send attempted but threw, will queue:', err);
      }
      return false;
    }

    function sendDigitsOrQueue(digits) {
      const call = window.activeCall;
      if (!call) {
        window._dtmfQueue.push(digits);
        addHistory('Queued (no call): ' + digits);
        setStatus('Queued DTMF: ' + digits);
        scheduleAutoFlush();
        return;
      }

      const status = (typeof call.state === 'function') ? call.state() : (call.status || call._status || call.connectionState || null);
      const isConnected = (status === 'connected' || status === 'open' || status === 'established' || status === 'connected');

      if (isConnected) {
        const ok = trySendNow(call, digits);
        if (ok) { setStatus('Sent DTMF: ' + digits); return; }
        window._dtmfQueue.push(digits);
        addHistory('Queued (send method missing): ' + digits);
        setStatus('Queued DTMF: ' + digits);
        scheduleAutoFlush();
        return;
      } else {
        const attempted = trySendNow(call, digits);
        if (attempted) { setStatus('Sent DTMF (attempt): ' + digits); return; }
        window._dtmfQueue.push(digits);
        addHistory('Queued (not connected): ' + digits);
        setStatus('Queued DTMF: ' + digits);
        scheduleAutoFlush();
        return;
      }
    }

    function flushDtmfQueue() {
      if (!window._dtmfQueue || window._dtmfQueue.length === 0) return;
      const call = window.activeCall;
      for (let i = 0; i < window._dtmfQueue.length; i++) {
        const seq = window._dtmfQueue[i];
        const attempted = trySendNow(call, seq);
        if (attempted) {
          addHistory('Flushed & Sent: ' + seq);
        } else {
          console.debug('Could not send queued seq now:', seq);
        }
      }
      const remaining = [];
      for (const seq of window._dtmfQueue) {
        const callNow = window.activeCall;
        const couldSend = callNow && (typeof callNow.sendDigits === 'function' || typeof callNow.dtmf === 'function' || typeof callNow.sendTone === 'function' || typeof callNow._sendDigits === 'function');
        if (!couldSend) remaining.push(seq);
      }
      window._dtmfQueue = remaining;
      setStatus('Flushed queued DTMF (remaining: ' + window._dtmfQueue.length + ')');
    }

    let _flushTimeouts = [];
    function scheduleAutoFlush() {
      _flushTimeouts.forEach(t => clearTimeout(t));
      _flushTimeouts = [];
      _flushTimeouts.push(setTimeout(() => { try { flushDtmfQueue(); } catch(e){console.error(e);} }, 400));
      _flushTimeouts.push(setTimeout(() => { try { flushDtmfQueue(); } catch(e){console.error(e);} }, 900));
      _flushTimeouts.push(setTimeout(() => { try { flushDtmfQueue(); } catch(e){console.error(e);} }, 1800));
    }

    // Keypad wiring
    document.querySelectorAll('.dtmf').forEach(btn => {
      btn.addEventListener('click', () => {
        const d = btn.getAttribute('data-digit');
        sendDigitsOrQueue(d);
      });
    });

    document.getElementById('sendSeq').addEventListener('click', () => {
      const seq = (document.getElementById('dtmfSeq').value || '').trim();
      if (!seq) return;
      if (!/^[0-9*#wW]+$/.test(seq)) { alert('Invalid characters in sequence'); return; }
      sendDigitsOrQueue(seq.replace(/W/g,'w'));
    });

    document.getElementById('flushNow').addEventListener('click', () => {
      addHistory('Manual flush requested');
      flushDtmfQueue();
    });

    /***** Start button handler *****/
    startBtn.addEventListener('click', async () => {
      await startDevice();
    });

  </script>
</body>
</html>
