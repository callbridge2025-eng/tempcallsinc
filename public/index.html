<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Twilio Browser Receiver (auto-detect)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;display:flex;align-items:center;justify-content:center;height:100vh;margin:0;background:#f6f8fa;}
    .card{background:#fff;padding:22px;border-radius:12px;box-shadow:0 6px 20px rgba(0,0,0,0.08);width:420px;text-align:center;}
    button{padding:10px 16px;border-radius:8px;border:none;background:#0b74de;color:#fff;font-weight:600;cursor:pointer;}
    #status{margin:12px 0;color:#333;}
    #incoming{display:none;margin-top:12px;}
    #answer, #reject{margin:6px;}
    .small{font-size:13px;color:#666;}
    pre {text-align:left; margin:8px 0; max-height:180px; overflow:auto; background:#f0f3f6; padding:8px; border-radius:6px;}
  </style>

  <!-- User-provided CDN (you said you use this) -->
  <script src="https://unpkg.com/@twilio/voice-sdk@2.16.0/dist/twilio.min.js"></script>
</head>
<body>
  <div class="card">
    <h2>Twilio Browser Receiver</h2>

    <div id="status">Click <strong>Enable calls</strong> to allow microphone & register device.</div>
    <div style="margin:10px 0">
      <button id="startBtn">Enable calls</button>
    </div>

    <div class="small">Keep this tab open. Incoming calls to your Twilio number will ring here.</div>

    <div id="incoming">
      <p><strong id="fromLabel">Incoming call</strong></p>
      <div>
        <button id="answer">Answer</button>
        <button id="reject" style="background:#e23b3b">Reject</button>
      </div>
    </div>

    <div style="margin-top:14px">
      <button id="muteToggle">Mute</button>
    </div>
<!-- ===== DTMF keypad (paste into your page UI) ===== -->
<div id="dtmfWrap" style="margin-top:12px; text-align:center;">
  <div style="margin-bottom:6px; font-size:13px; color:#666;">DTMF keypad — press while a call is active</div>
  <div id="dtmfKeys" style="display:grid; grid-template-columns:repeat(3,1fr); gap:6px; max-width:220px; margin:0 auto;">
    <!-- row 1 -->
    <button class="dtmf" data-digit="1">1</button>
    <button class="dtmf" data-digit="2">2</button>
    <button class="dtmf" data-digit="3">3</button>
    <!-- row 2 -->
    <button class="dtmf" data-digit="4">4</button>
    <button class="dtmf" data-digit="5">5</button>
    <button class="dtmf" data-digit="6">6</button>
    <!-- row 3 -->
    <button class="dtmf" data-digit="7">7</button>
    <button class="dtmf" data-digit="8">8</button>
    <button class="dtmf" data-digit="9">9</button>
    <!-- row 4 -->
    <button class="dtmf" data-digit="*">*</button>
    <button class="dtmf" data-digit="0">0</button>
    <button class="dtmf" data-digit="#">#</button>
  </div>

  <div style="margin-top:8px;">
    <button id="sendSeq" style="margin-right:8px;">Send sequence</button>
    <input id="dtmfSeq" placeholder="e.g. 123w45#" style="width:140px;padding:6px;border-radius:6px;border:1px solid #ddd;" />
  </div>
  <div style="font-size:12px;color:#888;margin-top:6px;">
    Use <code>w</code> to pause (~500ms). Allowed: 0–9, *, #, w.
  </div>
</div>

<script>
  // ASSUMPTION: this page defines `activeCall` when a call arrives (as in the page I gave earlier).
  // This snippet uses activeCall.sendDigits(digit) per Twilio Call API (v2).
  function sendDigit(d) {
    if (!window.activeCall) {
      console.warn('No active call — cannot send DTMF');
      setStatus && setStatus('No active call to send DTMF');
      return;
    }
    try {
      // call.sendDigits accepts a string of digits, e.g. '1' or '123#' or '1w2'
      // Each 'w' causes a 500ms pause.
      window.activeCall.sendDigits(String(d));
      setStatus && setStatus('Sent DTMF: ' + d);
    } catch (err) {
      console.error('sendDigits failed', err);
      setStatus && setStatus('DTMF send failed: ' + (err && err.message ? err.message : err));
    }
  }

  // wire up keypad buttons
  document.querySelectorAll('.dtmf').forEach(btn => {
    btn.addEventListener('click', () => {
      const d = btn.getAttribute('data-digit');
      sendDigit(d);
    });
  });

  // send sequence textbox + button
  const sendSeqBtn = document.getElementById('sendSeq');
  const seqInput = document.getElementById('dtmfSeq');
  sendSeqBtn.addEventListener('click', () => {
    const seq = (seqInput.value || '').trim();
    if (!seq) return;
    // validate allowed chars quickly
    if (!/^[0-9*#wW]+$/.test(seq)) {
      alert('Sequence includes invalid characters. Use 0-9, *, #, w.');
      return;
    }
    // normalize to lowercase w
    const normalized = seq.replace(/W/g, 'w');
    sendDigit(normalized);
  });
</script>


    <div style="margin-top:12px">
      <details><summary>Debug: detected Twilio global (open this and check console)</summary>
        <pre id="twilioDebug">(not loaded yet)</pre>
      </details>
    </div>
  </div>

  <script>
    // Debug helper: detect Twilio export shape and find a Device constructor.
    function detectTwilioDeviceConstructor() {
      // Common global names that different bundles expose
      const candidates = [
        window.Twilio,
        window.TwilioVoice,
        window.TwilioVoiceSDK,
        window.TwilioClient,
        window.default,              // unlikely
        (window.Twilio && window.Twilio.default), // some UMD builds
        (window.Twilio && window.Twilio.Device),
        (window.Twilio && window.Twilio.Device && window.Twilio.Device.Device)
      ];

      // Collect a map of keys available on window for easier debugging
      const twilioGlobal = window.Twilio || window.TwilioVoice || window.TwilioVoiceSDK || window.TwilioClient || window.Twilio || null;

      // Helper to test an object for a Device-like constructor
      function looksLikeConstructor(fn) {
        return typeof fn === 'function';
      }

      // Try a list of likely access paths
      const accessPaths = [
        ['window.Twilio', window.Twilio],
        ['window.Twilio && window.Twilio.Device', (window.Twilio && window.Twilio.Device)],
        ['window.Twilio.default', (window.Twilio && window.Twilio.default)],
        ['window.Twilio.default.Device', (window.Twilio && window.Twilio.default && window.Twilio.default.Device)],
        ['window.TwilioVoice', window.TwilioVoice],
        ['window.TwilioVoice.Device', (window.TwilioVoice && window.TwilioVoice.Device)],
        ['window.TwilioVoice.default', (window.TwilioVoice && window.TwilioVoice.default)],
        ['window.TwilioVoice.default.Device', (window.TwilioVoice && window.TwilioVoice.default && window.TwilioVoice.default.Device)],
        ['window["@twilio/voice-sdk"] (rare)', window['@twilio/voice-sdk']]
      ];

      // Check each path
      for (const [path, val] of accessPaths) {
        if (looksLikeConstructor(val)) {
          return { constructor: val, path, twilioGlobalSnapshot: snapshot(twilioGlobal) };
        }
        // sometimes Device is a property on the object
        if (val && typeof val === 'object') {
          // try .Device
          if (looksLikeConstructor(val.Device)) return { constructor: val.Device, path: path + '.Device', twilioGlobalSnapshot: snapshot(twilioGlobal) };
          // try default property
          if (looksLikeConstructor(val.default)) return { constructor: val.default, path: path + '.default', twilioGlobalSnapshot: snapshot(twilioGlobal) };
          if (val.default && typeof val.default === 'object' && looksLikeConstructor(val.default.Device)) {
            return { constructor: val.default.Device, path: path + '.default.Device', twilioGlobalSnapshot: snapshot(twilioGlobal) };
          }
        }
      }

      // nothing found — return a descriptive object
      return { constructor: null, path: null, twilioGlobalSnapshot: snapshot(twilioGlobal) };

      function snapshot(obj) {
        if (!obj) return null;
        try {
          // list keys, but not deep values
          return Object.keys(obj).slice(0,50);
        } catch (e) {
          return String(obj);
        }
      }
    }

    // UI refs
    const startBtn = document.getElementById('startBtn');
    const incomingBox = document.getElementById('incoming');
    const fromLabel = document.getElementById('fromLabel');
    const statusEl = document.getElementById('status');
    const debugPre = document.getElementById('twilioDebug');

    let device = null;
    let activeCall = null;
    let muted = false;

    function setStatus(t) { statusEl.innerText = t; }

    async function fetchToken() {
      const res = await fetch('/token');
      if (!res.ok) {
        const b = await res.json().catch(()=>({ error: 'unknown' }));
        throw new Error(b.error || 'Failed to fetch token');
      }
      const j = await res.json();
      return j.token;
    }

    async function startDevice() {
      setStatus('Fetching token…');
      try {
        const token = await fetchToken();

        // Detect constructor
        const detected = detectTwilioDeviceConstructor();
        console.log('Detected Twilio global:', detected.twilioGlobalSnapshot, 'chosen path:', detected.path);
        debugPre.innerText = 'Detected global keys: ' + JSON.stringify(detected.twilioGlobalSnapshot, null, 0) + '\nChosen path: ' + String(detected.path);

        if (!detected.constructor) {
          setStatus('Twilio SDK loaded but Device constructor not found. See console for details.');
          console.error('Twilio SDK loaded but could not find Device constructor. Snapshot:', detected.twilioGlobalSnapshot);
          return;
        }

        const DeviceCtor = detected.constructor;
        // Create device instance (v2 usage: new Device(token))
        try {
          device = new DeviceCtor(token);
        } catch (ctorErr) {
          console.error('Failed constructing Device with detected constructor. Constructor type:', typeof DeviceCtor, DeviceCtor);
          setStatus('Failed to create Device — constructor invocation threw an error (see console).');
          return;
        }

        // Register event listeners (v2 style)
        device.on && device.on('registered', () => {
          setStatus('Ready — waiting for calls.');
          startBtn.style.display = 'none';
        });

        device.on && device.on('registrationError', (err) => {
          console.error('registrationError', err);
          setStatus('Registration error: ' + (err && err.message ? err.message : String(err)));
        });

        device.on && device.on('unregistered', () => {
          setStatus('Device unregistered');
          startBtn.style.display = '';
        });

        device.on && device.on('incoming', (call) => {
          activeCall = call;
          const from = call.parameters && call.parameters.From ? call.parameters.From : 'Unknown';
          fromLabel.innerText = 'Incoming call from ' + from;
          incomingBox.style.display = 'block';
          setStatus('Incoming call from ' + from);

          // call lifecycle events
          call.on && call.on('connected', () => setStatus('Call connected'));
          call.on && call.on('disconnected', () => {
            setStatus('Call disconnected');
            incomingBox.style.display = 'none';
            activeCall = null;
            muted = false;
          });
          call.on && call.on('failed', (err) => {
            console.error('call failed', err);
            setStatus('Call failed: ' + (err && err.message ? err.message : String(err)));
          });
        });

        // v2: register to receive incoming calls (also triggers mic permissions)
        if (device.register) {
          await device.register();
        } else {
          console.warn('Device.register() method not present on detected Device; registered anyway if automatic.');
        }

      } catch (err) {
        console.error('startDevice error', err);
        setStatus('Initialization failed: ' + (err && err.message ? err.message : String(err)));
      }
    }

    // Buttons handlers
    startBtn.addEventListener('click', async () => {
      // must be a user gesture to start audio
      await startDevice();
    });

    document.getElementById('answer').addEventListener('click', async () => {
      if (!activeCall) return;
      try {
        await activeCall.accept();
        setStatus('Call answered');
        incomingBox.style.display = 'none';
      } catch (e) {
        console.error('Answer error', e);
      }
    });

    document.getElementById('reject').addEventListener('click', () => {
      if (!activeCall) return;
      try {
        activeCall.reject();
        setStatus('Call rejected');
        incomingBox.style.display = 'none';
        activeCall = null;
      } catch (e) {
        console.error('Reject failed', e);
      }
    });

    document.getElementById('muteToggle').addEventListener('click', () => {
      if (!activeCall) {
        setStatus('No active call to mute/unmute');
        return;
      }
      try {
        muted = !muted;
        activeCall.mute && activeCall.mute(muted);
        setStatus(muted ? 'Muted' : 'Unmuted');
      } catch (e) {
        console.error('Mute toggle failed', e);
      }
    });
  </script>
</body>
</html>
